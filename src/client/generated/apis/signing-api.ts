/* tslint:disable */
/* eslint-disable */
/**
 * W3S
 * All W3S APIs
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { SignDeveloperMessage200Response } from '../models';
// @ts-ignore
import { SignDeveloperTypedData200Response } from '../models';
// @ts-ignore
import { SignMessageForDeveloperRequest } from '../models';
// @ts-ignore
import { SignMessageForEndUserRequest } from '../models';
// @ts-ignore
import { SignMessageForEndUserResponse } from '../models';
// @ts-ignore
import { SignTypedDataForDeveloperRequest } from '../models';
// @ts-ignore
import { SignTypedDataForEndUserRequest } from '../models';
// @ts-ignore
import { SignTypedDataForEndUserResponse } from '../models';
// @ts-ignore
import { SignUserMessage200Response } from '../models';
// @ts-ignore
import { SignUserTypedData200Response } from '../models';
/**
 * SigningApi - axios parameter creator
 * @export
 */
export const SigningApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Sign the EIP-191 message from a specified developer-controlled wallet. Please note that not all the Dapps currently support Smart Contract Account (SCA), the difference between EOA and SCA can be found in the [account types guide](https://developers.circle.com/w3s/docs/programmable-wallets-account-types), and you can check the list of Dapps that support SCA: https://eip1271.io/.
         * @summary Sign message
         * @param {SignMessageForDeveloperRequest} signMessageForDeveloperRequest Sign message for developer request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signDeveloperMessage: async (signMessageForDeveloperRequest: SignMessageForDeveloperRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signMessageForDeveloperRequest' is not null or undefined
            assertParamExists('signDeveloperMessage', 'signMessageForDeveloperRequest', signMessageForDeveloperRequest)
            const localVarPath = `/developer/sign/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signMessageForDeveloperRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sign the EIP-712 typed structured data from a specified developer-controlled wallet. Please note that not all the Dapps currently support Smart Contract Account (SCA), the difference between EOA and SCA can be found in the [account types guide](https://developers.circle.com/w3s/docs/programmable-wallets-account-types), and you can check the list of Dapps that support SCA: https://eip1271.io/.
         * @summary Sign typed data
         * @param {SignTypedDataForDeveloperRequest} signTypedDataForDeveloperRequest Sign message for developer request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signDeveloperTypedData: async (signTypedDataForDeveloperRequest: SignTypedDataForDeveloperRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signTypedDataForDeveloperRequest' is not null or undefined
            assertParamExists('signDeveloperTypedData', 'signTypedDataForDeveloperRequest', signTypedDataForDeveloperRequest)
            const localVarPath = `/developer/sign/typedData`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signTypedDataForDeveloperRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a challenge for signing the EIP-191 message from a specified user-controlled wallet. Please note that not all the Dapps currently support Smart Contract Account (SCA), the difference between EOA and SCA can be found in the [account types guide](https://developers.circle.com/w3s/docs/programmable-wallets-account-types), and you can check the list of Dapps that support SCA: https://eip1271.io/.
         * @summary Create a challenge to sign message
         * @param {string} xUserToken User token
         * @param {SignMessageForEndUserRequest} signMessageForEndUserRequest Sign message for end user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUserMessage: async (xUserToken: string, signMessageForEndUserRequest: SignMessageForEndUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xUserToken' is not null or undefined
            assertParamExists('signUserMessage', 'xUserToken', xUserToken)
            // verify required parameter 'signMessageForEndUserRequest' is not null or undefined
            assertParamExists('signUserMessage', 'signMessageForEndUserRequest', signMessageForEndUserRequest)
            const localVarPath = `/user/sign/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xUserToken != null) {
                localVarHeaderParameter['X-User-Token'] = String(xUserToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signMessageForEndUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a challenge for signing the EIP-712 typed structured data from a specified user-controlled wallet. Please note that not all the Dapps currently support Smart Contract Account (SCA), the difference between EOA and SCA can be found in the [account types guide](https://developers.circle.com/w3s/docs/programmable-wallets-account-types), and you can check the list of Dapps that support SCA: https://eip1271.io/.
         * @summary Create a challenge to sign typed data
         * @param {string} xUserToken User token
         * @param {SignTypedDataForEndUserRequest} signTypedDataForEndUserRequest Sign typed data for end user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUserTypedData: async (xUserToken: string, signTypedDataForEndUserRequest: SignTypedDataForEndUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xUserToken' is not null or undefined
            assertParamExists('signUserTypedData', 'xUserToken', xUserToken)
            // verify required parameter 'signTypedDataForEndUserRequest' is not null or undefined
            assertParamExists('signUserTypedData', 'signTypedDataForEndUserRequest', signTypedDataForEndUserRequest)
            const localVarPath = `/user/sign/typedData`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xUserToken != null) {
                localVarHeaderParameter['X-User-Token'] = String(xUserToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signTypedDataForEndUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SigningApi - functional programming interface
 * @export
 */
export const SigningApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SigningApiAxiosParamCreator(configuration)
    return {
        /**
         * Sign the EIP-191 message from a specified developer-controlled wallet. Please note that not all the Dapps currently support Smart Contract Account (SCA), the difference between EOA and SCA can be found in the [account types guide](https://developers.circle.com/w3s/docs/programmable-wallets-account-types), and you can check the list of Dapps that support SCA: https://eip1271.io/.
         * @summary Sign message
         * @param {SignMessageForDeveloperRequest} signMessageForDeveloperRequest Sign message for developer request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signDeveloperMessage(signMessageForDeveloperRequest: SignMessageForDeveloperRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignDeveloperMessage200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signDeveloperMessage(signMessageForDeveloperRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sign the EIP-712 typed structured data from a specified developer-controlled wallet. Please note that not all the Dapps currently support Smart Contract Account (SCA), the difference between EOA and SCA can be found in the [account types guide](https://developers.circle.com/w3s/docs/programmable-wallets-account-types), and you can check the list of Dapps that support SCA: https://eip1271.io/.
         * @summary Sign typed data
         * @param {SignTypedDataForDeveloperRequest} signTypedDataForDeveloperRequest Sign message for developer request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signDeveloperTypedData(signTypedDataForDeveloperRequest: SignTypedDataForDeveloperRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignDeveloperTypedData200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signDeveloperTypedData(signTypedDataForDeveloperRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates a challenge for signing the EIP-191 message from a specified user-controlled wallet. Please note that not all the Dapps currently support Smart Contract Account (SCA), the difference between EOA and SCA can be found in the [account types guide](https://developers.circle.com/w3s/docs/programmable-wallets-account-types), and you can check the list of Dapps that support SCA: https://eip1271.io/.
         * @summary Create a challenge to sign message
         * @param {string} xUserToken User token
         * @param {SignMessageForEndUserRequest} signMessageForEndUserRequest Sign message for end user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signUserMessage(xUserToken: string, signMessageForEndUserRequest: SignMessageForEndUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignUserMessage200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signUserMessage(xUserToken, signMessageForEndUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates a challenge for signing the EIP-712 typed structured data from a specified user-controlled wallet. Please note that not all the Dapps currently support Smart Contract Account (SCA), the difference between EOA and SCA can be found in the [account types guide](https://developers.circle.com/w3s/docs/programmable-wallets-account-types), and you can check the list of Dapps that support SCA: https://eip1271.io/.
         * @summary Create a challenge to sign typed data
         * @param {string} xUserToken User token
         * @param {SignTypedDataForEndUserRequest} signTypedDataForEndUserRequest Sign typed data for end user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signUserTypedData(xUserToken: string, signTypedDataForEndUserRequest: SignTypedDataForEndUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignUserTypedData200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signUserTypedData(xUserToken, signTypedDataForEndUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SigningApi - factory interface
 * @export
 */
export const SigningApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SigningApiFp(configuration)
    return {
        /**
         * Sign the EIP-191 message from a specified developer-controlled wallet. Please note that not all the Dapps currently support Smart Contract Account (SCA), the difference between EOA and SCA can be found in the [account types guide](https://developers.circle.com/w3s/docs/programmable-wallets-account-types), and you can check the list of Dapps that support SCA: https://eip1271.io/.
         * @summary Sign message
         * @param {SignMessageForDeveloperRequest} signMessageForDeveloperRequest Sign message for developer request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signDeveloperMessage(signMessageForDeveloperRequest: SignMessageForDeveloperRequest, options?: any): AxiosPromise<SignDeveloperMessage200Response> {
            return localVarFp.signDeveloperMessage(signMessageForDeveloperRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Sign the EIP-712 typed structured data from a specified developer-controlled wallet. Please note that not all the Dapps currently support Smart Contract Account (SCA), the difference between EOA and SCA can be found in the [account types guide](https://developers.circle.com/w3s/docs/programmable-wallets-account-types), and you can check the list of Dapps that support SCA: https://eip1271.io/.
         * @summary Sign typed data
         * @param {SignTypedDataForDeveloperRequest} signTypedDataForDeveloperRequest Sign message for developer request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signDeveloperTypedData(signTypedDataForDeveloperRequest: SignTypedDataForDeveloperRequest, options?: any): AxiosPromise<SignDeveloperTypedData200Response> {
            return localVarFp.signDeveloperTypedData(signTypedDataForDeveloperRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a challenge for signing the EIP-191 message from a specified user-controlled wallet. Please note that not all the Dapps currently support Smart Contract Account (SCA), the difference between EOA and SCA can be found in the [account types guide](https://developers.circle.com/w3s/docs/programmable-wallets-account-types), and you can check the list of Dapps that support SCA: https://eip1271.io/.
         * @summary Create a challenge to sign message
         * @param {string} xUserToken User token
         * @param {SignMessageForEndUserRequest} signMessageForEndUserRequest Sign message for end user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUserMessage(xUserToken: string, signMessageForEndUserRequest: SignMessageForEndUserRequest, options?: any): AxiosPromise<SignUserMessage200Response> {
            return localVarFp.signUserMessage(xUserToken, signMessageForEndUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a challenge for signing the EIP-712 typed structured data from a specified user-controlled wallet. Please note that not all the Dapps currently support Smart Contract Account (SCA), the difference between EOA and SCA can be found in the [account types guide](https://developers.circle.com/w3s/docs/programmable-wallets-account-types), and you can check the list of Dapps that support SCA: https://eip1271.io/.
         * @summary Create a challenge to sign typed data
         * @param {string} xUserToken User token
         * @param {SignTypedDataForEndUserRequest} signTypedDataForEndUserRequest Sign typed data for end user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUserTypedData(xUserToken: string, signTypedDataForEndUserRequest: SignTypedDataForEndUserRequest, options?: any): AxiosPromise<SignUserTypedData200Response> {
            return localVarFp.signUserTypedData(xUserToken, signTypedDataForEndUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SigningApi - object-oriented interface
 * @export
 * @class SigningApi
 * @extends {BaseAPI}
 */
export class SigningApi extends BaseAPI {
    /**
     * Sign the EIP-191 message from a specified developer-controlled wallet. Please note that not all the Dapps currently support Smart Contract Account (SCA), the difference between EOA and SCA can be found in the [account types guide](https://developers.circle.com/w3s/docs/programmable-wallets-account-types), and you can check the list of Dapps that support SCA: https://eip1271.io/.
     * @summary Sign message
     * @param {SignMessageForDeveloperRequest} signMessageForDeveloperRequest Sign message for developer request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigningApi
     */
    public signDeveloperMessage(signMessageForDeveloperRequest: SignMessageForDeveloperRequest, options?: AxiosRequestConfig) {
        return SigningApiFp(this.configuration).signDeveloperMessage(signMessageForDeveloperRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sign the EIP-712 typed structured data from a specified developer-controlled wallet. Please note that not all the Dapps currently support Smart Contract Account (SCA), the difference between EOA and SCA can be found in the [account types guide](https://developers.circle.com/w3s/docs/programmable-wallets-account-types), and you can check the list of Dapps that support SCA: https://eip1271.io/.
     * @summary Sign typed data
     * @param {SignTypedDataForDeveloperRequest} signTypedDataForDeveloperRequest Sign message for developer request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigningApi
     */
    public signDeveloperTypedData(signTypedDataForDeveloperRequest: SignTypedDataForDeveloperRequest, options?: AxiosRequestConfig) {
        return SigningApiFp(this.configuration).signDeveloperTypedData(signTypedDataForDeveloperRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a challenge for signing the EIP-191 message from a specified user-controlled wallet. Please note that not all the Dapps currently support Smart Contract Account (SCA), the difference between EOA and SCA can be found in the [account types guide](https://developers.circle.com/w3s/docs/programmable-wallets-account-types), and you can check the list of Dapps that support SCA: https://eip1271.io/.
     * @summary Create a challenge to sign message
     * @param {string} xUserToken User token
     * @param {SignMessageForEndUserRequest} signMessageForEndUserRequest Sign message for end user request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigningApi
     */
    public signUserMessage(xUserToken: string, signMessageForEndUserRequest: SignMessageForEndUserRequest, options?: AxiosRequestConfig) {
        return SigningApiFp(this.configuration).signUserMessage(xUserToken, signMessageForEndUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a challenge for signing the EIP-712 typed structured data from a specified user-controlled wallet. Please note that not all the Dapps currently support Smart Contract Account (SCA), the difference between EOA and SCA can be found in the [account types guide](https://developers.circle.com/w3s/docs/programmable-wallets-account-types), and you can check the list of Dapps that support SCA: https://eip1271.io/.
     * @summary Create a challenge to sign typed data
     * @param {string} xUserToken User token
     * @param {SignTypedDataForEndUserRequest} signTypedDataForEndUserRequest Sign typed data for end user request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigningApi
     */
    public signUserTypedData(xUserToken: string, signTypedDataForEndUserRequest: SignTypedDataForEndUserRequest, options?: AxiosRequestConfig) {
        return SigningApiFp(this.configuration).signUserTypedData(xUserToken, signTypedDataForEndUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

