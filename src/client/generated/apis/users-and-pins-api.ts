/* tslint:disable */
/* eslint-disable */
/**
 * W3S
 * All W3S APIs
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ChangePinRequest } from '../models';
// @ts-ignore
import { CreateUserPinRestoreChallenge200Response } from '../models';
// @ts-ignore
import { CreateUserRequest } from '../models';
// @ts-ignore
import { CreateUserWithPinChallenge200Response } from '../models';
// @ts-ignore
import { GenerateUserTokenRequest } from '../models';
// @ts-ignore
import { GetUser200Response } from '../models';
// @ts-ignore
import { GetUserByToken200Response } from '../models';
// @ts-ignore
import { GetUserChallenge200Response } from '../models';
// @ts-ignore
import { GetUserToken200Response } from '../models';
// @ts-ignore
import { ListUserChallenges200Response } from '../models';
// @ts-ignore
import { ListUsers200Response } from '../models';
// @ts-ignore
import { RestorePinRequest } from '../models';
// @ts-ignore
import { SetPinAndInitWalletRequest } from '../models';
// @ts-ignore
import { SetPinRequest } from '../models';
// @ts-ignore
import { UpdateUserPinChallenge200Response } from '../models';
/**
 * UsersAndPinsApi - axios parameter creator
 * @export
 */
export const UsersAndPinsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a user.
         * @summary Create a user
         * @param {CreateUserRequest} createUserRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserRequest: CreateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserRequest' is not null or undefined
            assertParamExists('createUser', 'createUserRequest', createUserRequest)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a challenge for PIN setup without setting up wallets.
         * @summary Create a challenge for PIN setup
         * @param {string} xUserToken User token
         * @param {SetPinRequest} setPinRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserPinChallenge: async (xUserToken: string, setPinRequest: SetPinRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xUserToken' is not null or undefined
            assertParamExists('createUserPinChallenge', 'xUserToken', xUserToken)
            // verify required parameter 'setPinRequest' is not null or undefined
            assertParamExists('createUserPinChallenge', 'setPinRequest', setPinRequest)
            const localVarPath = `/user/pin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xUserToken != null) {
                localVarHeaderParameter['X-User-Token'] = String(xUserToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setPinRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a challenge to change a user\'s PIN via Security Questions.
         * @summary Create a challenge for PIN restore
         * @param {string} xUserToken User token
         * @param {RestorePinRequest} restorePinRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserPinRestoreChallenge: async (xUserToken: string, restorePinRequest: RestorePinRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xUserToken' is not null or undefined
            assertParamExists('createUserPinRestoreChallenge', 'xUserToken', xUserToken)
            // verify required parameter 'restorePinRequest' is not null or undefined
            assertParamExists('createUserPinRestoreChallenge', 'restorePinRequest', restorePinRequest)
            const localVarPath = `/user/pin/restore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xUserToken != null) {
                localVarHeaderParameter['X-User-Token'] = String(xUserToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(restorePinRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a challenge for PIN setup and create wallet(s)
         * @summary Create a challenge for PIN setup and create wallet(s)
         * @param {string} xUserToken User token
         * @param {SetPinAndInitWalletRequest} setPinAndInitWalletRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserWithPinChallenge: async (xUserToken: string, setPinAndInitWalletRequest: SetPinAndInitWalletRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xUserToken' is not null or undefined
            assertParamExists('createUserWithPinChallenge', 'xUserToken', xUserToken)
            // verify required parameter 'setPinAndInitWalletRequest' is not null or undefined
            assertParamExists('createUserWithPinChallenge', 'setPinAndInitWalletRequest', setPinAndInitWalletRequest)
            const localVarPath = `/user/initialize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xUserToken != null) {
                localVarHeaderParameter['X-User-Token'] = String(xUserToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setPinAndInitWalletRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user by ID.
         * @summary Get a user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s PIN and Security Question statuses.
         * @summary Get user status
         * @param {string} xUserToken User token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByToken: async (xUserToken: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xUserToken' is not null or undefined
            assertParamExists('getUserByToken', 'xUserToken', xUserToken)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xUserToken != null) {
                localVarHeaderParameter['X-User-Token'] = String(xUserToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status of a challenge.
         * @summary Get a challenge
         * @param {string} xUserToken User token
         * @param {string} id ExtChallenge id to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserChallenge: async (xUserToken: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xUserToken' is not null or undefined
            assertParamExists('getUserChallenge', 'xUserToken', xUserToken)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserChallenge', 'id', id)
            const localVarPath = `/user/challenges/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xUserToken != null) {
                localVarHeaderParameter['X-User-Token'] = String(xUserToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate user session and SDK secret key.
         * @summary Create a user token
         * @param {GenerateUserTokenRequest} generateUserTokenRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserToken: async (generateUserTokenRequest: GenerateUserTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateUserTokenRequest' is not null or undefined
            assertParamExists('getUserToken', 'generateUserTokenRequest', generateUserTokenRequest)
            const localVarPath = `/users/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateUserTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all challenges by status for a user.
         * @summary List challenges
         * @param {string} xUserToken User token
         * @param {ListUserChallengesStatusEnum} [status] Filter by external challenge status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserChallenges: async (xUserToken: string, status?: ListUserChallengesStatusEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xUserToken' is not null or undefined
            assertParamExists('listUserChallenges', 'xUserToken', xUserToken)
            const localVarPath = `/user/challenges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (xUserToken != null) {
                localVarHeaderParameter['X-User-Token'] = String(xUserToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the users under the entity, sorted by the create date DESC order.
         * @summary List users
         * @param {ListUsersPinStatusEnum} [pinStatus] Filter by the PIN status of the wallet.
         * @param {ListUsersSecurityQuestionStatusEnum} [securityQuestionStatus] Filter by the security question status of the wallet.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next n items before the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.   SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next n items after the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.   Some collections have a strict upper bound that will disregard this value. In case the specified value is higher  than the allowed limit, the collection limit will be used.   If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (pinStatus?: ListUsersPinStatusEnum, securityQuestionStatus?: ListUsersSecurityQuestionStatusEnum, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pinStatus !== undefined) {
                localVarQueryParameter['pinStatus'] = pinStatus;
            }

            if (securityQuestionStatus !== undefined) {
                localVarQueryParameter['securityQuestionStatus'] = securityQuestionStatus;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (pageBefore !== undefined) {
                localVarQueryParameter['pageBefore'] = pageBefore;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['pageAfter'] = pageAfter;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a challenge to update a user\'s PIN via existing PIN.
         * @summary Create a challenge to update PIN
         * @param {string} xUserToken User token
         * @param {ChangePinRequest} changePinRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPinChallenge: async (xUserToken: string, changePinRequest: ChangePinRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xUserToken' is not null or undefined
            assertParamExists('updateUserPinChallenge', 'xUserToken', xUserToken)
            // verify required parameter 'changePinRequest' is not null or undefined
            assertParamExists('updateUserPinChallenge', 'changePinRequest', changePinRequest)
            const localVarPath = `/user/pin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xUserToken != null) {
                localVarHeaderParameter['X-User-Token'] = String(xUserToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePinRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersAndPinsApi - functional programming interface
 * @export
 */
export const UsersAndPinsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersAndPinsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a user.
         * @summary Create a user
         * @param {CreateUserRequest} createUserRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserRequest: CreateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a challenge for PIN setup without setting up wallets.
         * @summary Create a challenge for PIN setup
         * @param {string} xUserToken User token
         * @param {SetPinRequest} setPinRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserPinChallenge(xUserToken: string, setPinRequest: SetPinRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserWithPinChallenge200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserPinChallenge(xUserToken, setPinRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a challenge to change a user\'s PIN via Security Questions.
         * @summary Create a challenge for PIN restore
         * @param {string} xUserToken User token
         * @param {RestorePinRequest} restorePinRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserPinRestoreChallenge(xUserToken: string, restorePinRequest: RestorePinRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserPinRestoreChallenge200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserPinRestoreChallenge(xUserToken, restorePinRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a challenge for PIN setup and create wallet(s)
         * @summary Create a challenge for PIN setup and create wallet(s)
         * @param {string} xUserToken User token
         * @param {SetPinAndInitWalletRequest} setPinAndInitWalletRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserWithPinChallenge(xUserToken: string, setPinAndInitWalletRequest: SetPinAndInitWalletRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserWithPinChallenge200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserWithPinChallenge(xUserToken, setPinAndInitWalletRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user by ID.
         * @summary Get a user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user\'s PIN and Security Question statuses.
         * @summary Get user status
         * @param {string} xUserToken User token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByToken(xUserToken: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserByToken200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByToken(xUserToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the status of a challenge.
         * @summary Get a challenge
         * @param {string} xUserToken User token
         * @param {string} id ExtChallenge id to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserChallenge(xUserToken: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserChallenge200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserChallenge(xUserToken, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate user session and SDK secret key.
         * @summary Create a user token
         * @param {GenerateUserTokenRequest} generateUserTokenRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserToken(generateUserTokenRequest: GenerateUserTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserToken200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserToken(generateUserTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all challenges by status for a user.
         * @summary List challenges
         * @param {string} xUserToken User token
         * @param {ListUserChallengesStatusEnum} [status] Filter by external challenge status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserChallenges(xUserToken: string, status?: ListUserChallengesStatusEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUserChallenges200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserChallenges(xUserToken, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all the users under the entity, sorted by the create date DESC order.
         * @summary List users
         * @param {ListUsersPinStatusEnum} [pinStatus] Filter by the PIN status of the wallet.
         * @param {ListUsersSecurityQuestionStatusEnum} [securityQuestionStatus] Filter by the security question status of the wallet.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next n items before the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.   SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next n items after the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.   Some collections have a strict upper bound that will disregard this value. In case the specified value is higher  than the allowed limit, the collection limit will be used.   If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(pinStatus?: ListUsersPinStatusEnum, securityQuestionStatus?: ListUsersSecurityQuestionStatusEnum, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(pinStatus, securityQuestionStatus, from, to, pageBefore, pageAfter, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a challenge to update a user\'s PIN via existing PIN.
         * @summary Create a challenge to update PIN
         * @param {string} xUserToken User token
         * @param {ChangePinRequest} changePinRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPinChallenge(xUserToken: string, changePinRequest: ChangePinRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateUserPinChallenge200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPinChallenge(xUserToken, changePinRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersAndPinsApi - factory interface
 * @export
 */
export const UsersAndPinsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersAndPinsApiFp(configuration)
    return {
        /**
         * Create a user.
         * @summary Create a user
         * @param {CreateUserRequest} createUserRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUserRequest: CreateUserRequest, options?: any): AxiosPromise<object> {
            return localVarFp.createUser(createUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a challenge for PIN setup without setting up wallets.
         * @summary Create a challenge for PIN setup
         * @param {string} xUserToken User token
         * @param {SetPinRequest} setPinRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserPinChallenge(xUserToken: string, setPinRequest: SetPinRequest, options?: any): AxiosPromise<CreateUserWithPinChallenge200Response> {
            return localVarFp.createUserPinChallenge(xUserToken, setPinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a challenge to change a user\'s PIN via Security Questions.
         * @summary Create a challenge for PIN restore
         * @param {string} xUserToken User token
         * @param {RestorePinRequest} restorePinRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserPinRestoreChallenge(xUserToken: string, restorePinRequest: RestorePinRequest, options?: any): AxiosPromise<CreateUserPinRestoreChallenge200Response> {
            return localVarFp.createUserPinRestoreChallenge(xUserToken, restorePinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a challenge for PIN setup and create wallet(s)
         * @summary Create a challenge for PIN setup and create wallet(s)
         * @param {string} xUserToken User token
         * @param {SetPinAndInitWalletRequest} setPinAndInitWalletRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserWithPinChallenge(xUserToken: string, setPinAndInitWalletRequest: SetPinAndInitWalletRequest, options?: any): AxiosPromise<CreateUserWithPinChallenge200Response> {
            return localVarFp.createUserWithPinChallenge(xUserToken, setPinAndInitWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user by ID.
         * @summary Get a user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s PIN and Security Question statuses.
         * @summary Get user status
         * @param {string} xUserToken User token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByToken(xUserToken: string, options?: any): AxiosPromise<GetUserByToken200Response> {
            return localVarFp.getUserByToken(xUserToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status of a challenge.
         * @summary Get a challenge
         * @param {string} xUserToken User token
         * @param {string} id ExtChallenge id to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserChallenge(xUserToken: string, id: string, options?: any): AxiosPromise<GetUserChallenge200Response> {
            return localVarFp.getUserChallenge(xUserToken, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate user session and SDK secret key.
         * @summary Create a user token
         * @param {GenerateUserTokenRequest} generateUserTokenRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserToken(generateUserTokenRequest: GenerateUserTokenRequest, options?: any): AxiosPromise<GetUserToken200Response> {
            return localVarFp.getUserToken(generateUserTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List all challenges by status for a user.
         * @summary List challenges
         * @param {string} xUserToken User token
         * @param {ListUserChallengesStatusEnum} [status] Filter by external challenge status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserChallenges(xUserToken: string, status?: ListUserChallengesStatusEnum, options?: any): AxiosPromise<ListUserChallenges200Response> {
            return localVarFp.listUserChallenges(xUserToken, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all the users under the entity, sorted by the create date DESC order.
         * @summary List users
         * @param {ListUsersPinStatusEnum} [pinStatus] Filter by the PIN status of the wallet.
         * @param {ListUsersSecurityQuestionStatusEnum} [securityQuestionStatus] Filter by the security question status of the wallet.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next n items before the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.   SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next n items after the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.   Some collections have a strict upper bound that will disregard this value. In case the specified value is higher  than the allowed limit, the collection limit will be used.   If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(pinStatus?: ListUsersPinStatusEnum, securityQuestionStatus?: ListUsersSecurityQuestionStatusEnum, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: any): AxiosPromise<ListUsers200Response> {
            return localVarFp.listUsers(pinStatus, securityQuestionStatus, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a challenge to update a user\'s PIN via existing PIN.
         * @summary Create a challenge to update PIN
         * @param {string} xUserToken User token
         * @param {ChangePinRequest} changePinRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPinChallenge(xUserToken: string, changePinRequest: ChangePinRequest, options?: any): AxiosPromise<UpdateUserPinChallenge200Response> {
            return localVarFp.updateUserPinChallenge(xUserToken, changePinRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersAndPinsApi - object-oriented interface
 * @export
 * @class UsersAndPinsApi
 * @extends {BaseAPI}
 */
export class UsersAndPinsApi extends BaseAPI {
    /**
     * Create a user.
     * @summary Create a user
     * @param {CreateUserRequest} createUserRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersAndPinsApi
     */
    public createUser(createUserRequest: CreateUserRequest, options?: AxiosRequestConfig) {
        return UsersAndPinsApiFp(this.configuration).createUser(createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a challenge for PIN setup without setting up wallets.
     * @summary Create a challenge for PIN setup
     * @param {string} xUserToken User token
     * @param {SetPinRequest} setPinRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersAndPinsApi
     */
    public createUserPinChallenge(xUserToken: string, setPinRequest: SetPinRequest, options?: AxiosRequestConfig) {
        return UsersAndPinsApiFp(this.configuration).createUserPinChallenge(xUserToken, setPinRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a challenge to change a user\'s PIN via Security Questions.
     * @summary Create a challenge for PIN restore
     * @param {string} xUserToken User token
     * @param {RestorePinRequest} restorePinRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersAndPinsApi
     */
    public createUserPinRestoreChallenge(xUserToken: string, restorePinRequest: RestorePinRequest, options?: AxiosRequestConfig) {
        return UsersAndPinsApiFp(this.configuration).createUserPinRestoreChallenge(xUserToken, restorePinRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a challenge for PIN setup and create wallet(s)
     * @summary Create a challenge for PIN setup and create wallet(s)
     * @param {string} xUserToken User token
     * @param {SetPinAndInitWalletRequest} setPinAndInitWalletRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersAndPinsApi
     */
    public createUserWithPinChallenge(xUserToken: string, setPinAndInitWalletRequest: SetPinAndInitWalletRequest, options?: AxiosRequestConfig) {
        return UsersAndPinsApiFp(this.configuration).createUserWithPinChallenge(xUserToken, setPinAndInitWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user by ID.
     * @summary Get a user
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersAndPinsApi
     */
    public getUser(id: string, options?: AxiosRequestConfig) {
        return UsersAndPinsApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s PIN and Security Question statuses.
     * @summary Get user status
     * @param {string} xUserToken User token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersAndPinsApi
     */
    public getUserByToken(xUserToken: string, options?: AxiosRequestConfig) {
        return UsersAndPinsApiFp(this.configuration).getUserByToken(xUserToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the status of a challenge.
     * @summary Get a challenge
     * @param {string} xUserToken User token
     * @param {string} id ExtChallenge id to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersAndPinsApi
     */
    public getUserChallenge(xUserToken: string, id: string, options?: AxiosRequestConfig) {
        return UsersAndPinsApiFp(this.configuration).getUserChallenge(xUserToken, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate user session and SDK secret key.
     * @summary Create a user token
     * @param {GenerateUserTokenRequest} generateUserTokenRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersAndPinsApi
     */
    public getUserToken(generateUserTokenRequest: GenerateUserTokenRequest, options?: AxiosRequestConfig) {
        return UsersAndPinsApiFp(this.configuration).getUserToken(generateUserTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all challenges by status for a user.
     * @summary List challenges
     * @param {string} xUserToken User token
     * @param {ListUserChallengesStatusEnum} [status] Filter by external challenge status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersAndPinsApi
     */
    public listUserChallenges(xUserToken: string, status?: ListUserChallengesStatusEnum, options?: AxiosRequestConfig) {
        return UsersAndPinsApiFp(this.configuration).listUserChallenges(xUserToken, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all the users under the entity, sorted by the create date DESC order.
     * @summary List users
     * @param {ListUsersPinStatusEnum} [pinStatus] Filter by the PIN status of the wallet.
     * @param {ListUsersSecurityQuestionStatusEnum} [securityQuestionStatus] Filter by the security question status of the wallet.
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next n items before the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.   SHOULD NOT be used in conjuction with pageAfter. 
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next n items after the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.  SHOULD NOT be used in conjuction with pageBefore. 
     * @param {number} [pageSize] Limits the number of items to be returned.   Some collections have a strict upper bound that will disregard this value. In case the specified value is higher  than the allowed limit, the collection limit will be used.   If avoided, the collection will determine the page size itself. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersAndPinsApi
     */
    public listUsers(pinStatus?: ListUsersPinStatusEnum, securityQuestionStatus?: ListUsersSecurityQuestionStatusEnum, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return UsersAndPinsApiFp(this.configuration).listUsers(pinStatus, securityQuestionStatus, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a challenge to update a user\'s PIN via existing PIN.
     * @summary Create a challenge to update PIN
     * @param {string} xUserToken User token
     * @param {ChangePinRequest} changePinRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersAndPinsApi
     */
    public updateUserPinChallenge(xUserToken: string, changePinRequest: ChangePinRequest, options?: AxiosRequestConfig) {
        return UsersAndPinsApiFp(this.configuration).updateUserPinChallenge(xUserToken, changePinRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListUserChallengesStatusEnum = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS'
} as const;
export type ListUserChallengesStatusEnum = typeof ListUserChallengesStatusEnum[keyof typeof ListUserChallengesStatusEnum];
/**
 * @export
 */
export const ListUsersPinStatusEnum = {
    Enabled: 'ENABLED',
    Unset: 'UNSET',
    Locked: 'LOCKED'
} as const;
export type ListUsersPinStatusEnum = typeof ListUsersPinStatusEnum[keyof typeof ListUsersPinStatusEnum];
/**
 * @export
 */
export const ListUsersSecurityQuestionStatusEnum = {
    Enabled: 'ENABLED',
    Unset: 'UNSET',
    Locked: 'LOCKED'
} as const;
export type ListUsersSecurityQuestionStatusEnum = typeof ListUsersSecurityQuestionStatusEnum[keyof typeof ListUsersSecurityQuestionStatusEnum];
