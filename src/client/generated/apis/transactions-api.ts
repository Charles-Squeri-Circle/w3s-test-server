/* tslint:disable */
/* eslint-disable */
/**
 * W3S
 * All W3S APIs
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AccelerateTransactionForDeveloperRequest } from '../models';
// @ts-ignore
import { AccelerateTransactionForEndUserRequest } from '../models';
// @ts-ignore
import { CancelTransactionForDeveloperRequest } from '../models';
// @ts-ignore
import { CancelTransactionForEndUserRequest } from '../models';
// @ts-ignore
import { ContractExecutionTxnPinCodeRequest } from '../models';
// @ts-ignore
import { CreateContractExecutionTransactionForDeveloperRequest } from '../models';
// @ts-ignore
import { CreateDeveloperTransactionAccelerate200Response } from '../models';
// @ts-ignore
import { CreateDeveloperTransactionCancel200Response } from '../models';
// @ts-ignore
import { CreateDeveloperTransactionContractExecution200Response } from '../models';
// @ts-ignore
import { CreateDeveloperTransactionTransfer200Response } from '../models';
// @ts-ignore
import { CreateTransferEstimateFee200Response } from '../models';
// @ts-ignore
import { CreateTransferTransactionForDeveloperRequest } from '../models';
// @ts-ignore
import { CreateTransferTransactionForEndUserRequest } from '../models';
// @ts-ignore
import { CreateUserTransactionAccelerateChallenge200Response } from '../models';
// @ts-ignore
import { CreateUserTransactionCancelChallenge200Response } from '../models';
// @ts-ignore
import { CreateUserTransactionContractExecutionChallenge200Response } from '../models';
// @ts-ignore
import { CreateUserTransactionTransferChallenge200Response } from '../models';
// @ts-ignore
import { CreateValidateAddress200Response } from '../models';
// @ts-ignore
import { EstimateContractExecutionTransactionFeeRequest } from '../models';
// @ts-ignore
import { EstimateTransferTransactionFeeRequest } from '../models';
// @ts-ignore
import { GetTransaction200Response } from '../models';
// @ts-ignore
import { ListTransactions200Response } from '../models';
// @ts-ignore
import { ValidateAddressRequest } from '../models';
/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accelerates a specified on-chain digital asset transfer from a developer-controlled wallet. Additional gas fees may be incurred.
         * @summary Accelerate a transaction
         * @param {string} id Transaction ID
         * @param {AccelerateTransactionForDeveloperRequest} accelerateTransactionForDeveloperRequest Accelerate transaction for developer request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeveloperTransactionAccelerate: async (id: string, accelerateTransactionForDeveloperRequest: AccelerateTransactionForDeveloperRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createDeveloperTransactionAccelerate', 'id', id)
            // verify required parameter 'accelerateTransactionForDeveloperRequest' is not null or undefined
            assertParamExists('createDeveloperTransactionAccelerate', 'accelerateTransactionForDeveloperRequest', accelerateTransactionForDeveloperRequest)
            const localVarPath = `/developer/transactions/{id}/accelerate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accelerateTransactionForDeveloperRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels a specified on-chain digital asset transfer from a developer-controlled wallet. Gas fees may still be incurred.
         * @summary Cancel a transaction
         * @param {string} id Transaction ID
         * @param {CancelTransactionForDeveloperRequest} cancelTransactionForDeveloperRequest Cancel transaction for developer request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeveloperTransactionCancel: async (id: string, cancelTransactionForDeveloperRequest: CancelTransactionForDeveloperRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createDeveloperTransactionCancel', 'id', id)
            // verify required parameter 'cancelTransactionForDeveloperRequest' is not null or undefined
            assertParamExists('createDeveloperTransactionCancel', 'cancelTransactionForDeveloperRequest', cancelTransactionForDeveloperRequest)
            const localVarPath = `/developer/transactions/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelTransactionForDeveloperRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a transaction which executes a smart contract. ABI parameters must be passed in the request.
         * @summary Create a contract execution transaction
         * @param {CreateContractExecutionTransactionForDeveloperRequest} createContractExecutionTransactionForDeveloperRequest Create transaction for developer request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeveloperTransactionContractExecution: async (createContractExecutionTransactionForDeveloperRequest: CreateContractExecutionTransactionForDeveloperRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createContractExecutionTransactionForDeveloperRequest' is not null or undefined
            assertParamExists('createDeveloperTransactionContractExecution', 'createContractExecutionTransactionForDeveloperRequest', createContractExecutionTransactionForDeveloperRequest)
            const localVarPath = `/developer/transactions/contractExecution`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createContractExecutionTransactionForDeveloperRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiates an on-chain digital asset transfer from a specified developer-controlled wallet.
         * @summary Create a transfer transaction
         * @param {CreateTransferTransactionForDeveloperRequest} createTransferTransactionForDeveloperRequest Create transaction for developer request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeveloperTransactionTransfer: async (createTransferTransactionForDeveloperRequest: CreateTransferTransactionForDeveloperRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTransferTransactionForDeveloperRequest' is not null or undefined
            assertParamExists('createDeveloperTransactionTransfer', 'createTransferTransactionForDeveloperRequest', createTransferTransactionForDeveloperRequest)
            const localVarPath = `/developer/transactions/transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransferTransactionForDeveloperRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Estimates gas fees that will be incurred for a contract execution transaction, given its ABI parameters and blockchain.
         * @summary Estimate fee for a contract execution transaction
         * @param {EstimateContractExecutionTransactionFeeRequest} estimateContractExecutionTransactionFeeRequest Estimate transaction fee request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionEstimateFee: async (estimateContractExecutionTransactionFeeRequest: EstimateContractExecutionTransactionFeeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'estimateContractExecutionTransactionFeeRequest' is not null or undefined
            assertParamExists('createTransactionEstimateFee', 'estimateContractExecutionTransactionFeeRequest', estimateContractExecutionTransactionFeeRequest)
            const localVarPath = `/transactions/contractExecution/estimateFee`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(estimateContractExecutionTransactionFeeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Estimates gas fees that will be incurred for a transfer transaction; given its amount, blockchain, and token.
         * @summary Estimate fee for a transfer transaction
         * @param {EstimateTransferTransactionFeeRequest} estimateTransferTransactionFeeRequest Estimate transaction fee request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransferEstimateFee: async (estimateTransferTransactionFeeRequest: EstimateTransferTransactionFeeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'estimateTransferTransactionFeeRequest' is not null or undefined
            assertParamExists('createTransferEstimateFee', 'estimateTransferTransactionFeeRequest', estimateTransferTransactionFeeRequest)
            const localVarPath = `/transactions/transfer/estimateFee`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(estimateTransferTransactionFeeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a challenge for accelerating a specified on-chain digital asset transfer from a user-controlled wallet. Additional gas fees may be incurred.
         * @summary Create a Challenge to accelerate a transaction
         * @param {string} id Transaction ID
         * @param {string} xUserToken User token
         * @param {AccelerateTransactionForEndUserRequest} accelerateTransactionForEndUserRequest Accelerate transaction for end user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserTransactionAccelerateChallenge: async (id: string, xUserToken: string, accelerateTransactionForEndUserRequest: AccelerateTransactionForEndUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createUserTransactionAccelerateChallenge', 'id', id)
            // verify required parameter 'xUserToken' is not null or undefined
            assertParamExists('createUserTransactionAccelerateChallenge', 'xUserToken', xUserToken)
            // verify required parameter 'accelerateTransactionForEndUserRequest' is not null or undefined
            assertParamExists('createUserTransactionAccelerateChallenge', 'accelerateTransactionForEndUserRequest', accelerateTransactionForEndUserRequest)
            const localVarPath = `/user/transactions/{id}/accelerate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xUserToken != null) {
                localVarHeaderParameter['X-User-Token'] = String(xUserToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accelerateTransactionForEndUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a challenge for cancelling a specified on-chain digital asset transfer from a user-controlled wallet. Gas fees may still be incurred.
         * @summary Create a challenge to cancel a transaction
         * @param {string} id Transaction ID
         * @param {string} xUserToken User token
         * @param {CancelTransactionForEndUserRequest} cancelTransactionForEndUserRequest Cancel transaction for end user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserTransactionCancelChallenge: async (id: string, xUserToken: string, cancelTransactionForEndUserRequest: CancelTransactionForEndUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createUserTransactionCancelChallenge', 'id', id)
            // verify required parameter 'xUserToken' is not null or undefined
            assertParamExists('createUserTransactionCancelChallenge', 'xUserToken', xUserToken)
            // verify required parameter 'cancelTransactionForEndUserRequest' is not null or undefined
            assertParamExists('createUserTransactionCancelChallenge', 'cancelTransactionForEndUserRequest', cancelTransactionForEndUserRequest)
            const localVarPath = `/user/transactions/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xUserToken != null) {
                localVarHeaderParameter['X-User-Token'] = String(xUserToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelTransactionForEndUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a challenge for creating a transaction which executes a smart contract. ABI parameters must be passed in the request.
         * @summary Create a challenge for contract execution
         * @param {string} xUserToken User token
         * @param {ContractExecutionTxnPinCodeRequest} contractExecutionTxnPinCodeRequest Create transaction for end user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserTransactionContractExecutionChallenge: async (xUserToken: string, contractExecutionTxnPinCodeRequest: ContractExecutionTxnPinCodeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xUserToken' is not null or undefined
            assertParamExists('createUserTransactionContractExecutionChallenge', 'xUserToken', xUserToken)
            // verify required parameter 'contractExecutionTxnPinCodeRequest' is not null or undefined
            assertParamExists('createUserTransactionContractExecutionChallenge', 'contractExecutionTxnPinCodeRequest', contractExecutionTxnPinCodeRequest)
            const localVarPath = `/user/transactions/contractExecution`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xUserToken != null) {
                localVarHeaderParameter['X-User-Token'] = String(xUserToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractExecutionTxnPinCodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a challenge for initiating an on-chain digital asset transfer from a specified user-controlled wallet
         * @summary Create a challenge for a transfer
         * @param {string} xUserToken User token
         * @param {CreateTransferTransactionForEndUserRequest} createTransferTransactionForEndUserRequest Create transaction for end user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserTransactionTransferChallenge: async (xUserToken: string, createTransferTransactionForEndUserRequest: CreateTransferTransactionForEndUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xUserToken' is not null or undefined
            assertParamExists('createUserTransactionTransferChallenge', 'xUserToken', xUserToken)
            // verify required parameter 'createTransferTransactionForEndUserRequest' is not null or undefined
            assertParamExists('createUserTransactionTransferChallenge', 'createTransferTransactionForEndUserRequest', createTransferTransactionForEndUserRequest)
            const localVarPath = `/user/transactions/transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xUserToken != null) {
                localVarHeaderParameter['X-User-Token'] = String(xUserToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransferTransactionForEndUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirms that a specified address is valid for a given token on a certain blockchain.
         * @summary Validate an address
         * @param {ValidateAddressRequest} validateAddressRequest Validate address request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createValidateAddress: async (validateAddressRequest: ValidateAddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validateAddressRequest' is not null or undefined
            assertParamExists('createValidateAddress', 'validateAddressRequest', validateAddressRequest)
            const localVarPath = `/transactions/validateAddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validateAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves info for a single transaction using it\'s unique identifier.
         * @summary Get a transaction
         * @param {string} id Transaction id
         * @param {string} [xUserToken] User token
         * @param {GetTransactionTxTypeEnum} [txType] TxType filters on the TxType of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction: async (id: string, xUserToken?: string, txType?: GetTransactionTxTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransaction', 'id', id)
            const localVarPath = `/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (txType !== undefined) {
                localVarQueryParameter['txType'] = txType;
            }

            if (xUserToken != null) {
                localVarHeaderParameter['X-User-Token'] = String(xUserToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all transactions. Includes details such as status, source/destination, and transaction hash.
         * @summary List transactions
         * @param {string} [xUserToken] User token
         * @param {ListTransactionsBlockchainEnum} [blockchain] Blockchain filters on the blockchain of the transaction
         * @param {ListTransactionsCustodyTypeEnum} [custodyType] CustodyType filters on the CustodyType of the transaction
         * @param {string} [destinationAddress] DestinationAddress filters on the DestinationAddress of the transaction
         * @param {boolean} [includeAll] 
         * @param {ListTransactionsOperationEnum} [operation] Operation filters on the Operation of the transaction
         * @param {ListTransactionsStateEnum} [state] State filters on the state of the transaction
         * @param {string} [txHash] TxHash filters on the TxHash of the transaction
         * @param {ListTransactionsTxTypeEnum} [txType] TxType filters on the TxType of the transaction
         * @param {string} [walletIds] WalletIDs filters on the wallet ids of the transaction
         * @param {string} [from] From is the start time of the query, inclusive
         * @param {string} [to] To is the end time of the query, inclusive, default to current time
         * @param {string} [pageBefore] PageBefore is used to return items before the given item exclusively. SHOULD NOT be used in conjunction with pageAfter
         * @param {string} [pageAfter] PageAfter is used to return items after the given item exclusively. SHOULD NOT be used in conjunction with pageBefore
         * @param {number} [pageSize] PageSize is the number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions: async (xUserToken?: string, blockchain?: ListTransactionsBlockchainEnum, custodyType?: ListTransactionsCustodyTypeEnum, destinationAddress?: string, includeAll?: boolean, operation?: ListTransactionsOperationEnum, state?: ListTransactionsStateEnum, txHash?: string, txType?: ListTransactionsTxTypeEnum, walletIds?: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (blockchain !== undefined) {
                localVarQueryParameter['blockchain'] = blockchain;
            }

            if (custodyType !== undefined) {
                localVarQueryParameter['custodyType'] = custodyType;
            }

            if (destinationAddress !== undefined) {
                localVarQueryParameter['destinationAddress'] = destinationAddress;
            }

            if (includeAll !== undefined) {
                localVarQueryParameter['includeAll'] = includeAll;
            }

            if (operation !== undefined) {
                localVarQueryParameter['operation'] = operation;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (txHash !== undefined) {
                localVarQueryParameter['txHash'] = txHash;
            }

            if (txType !== undefined) {
                localVarQueryParameter['txType'] = txType;
            }

            if (walletIds !== undefined) {
                localVarQueryParameter['walletIds'] = walletIds;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (pageBefore !== undefined) {
                localVarQueryParameter['pageBefore'] = pageBefore;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['pageAfter'] = pageAfter;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (xUserToken != null) {
                localVarHeaderParameter['X-User-Token'] = String(xUserToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Accelerates a specified on-chain digital asset transfer from a developer-controlled wallet. Additional gas fees may be incurred.
         * @summary Accelerate a transaction
         * @param {string} id Transaction ID
         * @param {AccelerateTransactionForDeveloperRequest} accelerateTransactionForDeveloperRequest Accelerate transaction for developer request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeveloperTransactionAccelerate(id: string, accelerateTransactionForDeveloperRequest: AccelerateTransactionForDeveloperRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDeveloperTransactionAccelerate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeveloperTransactionAccelerate(id, accelerateTransactionForDeveloperRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancels a specified on-chain digital asset transfer from a developer-controlled wallet. Gas fees may still be incurred.
         * @summary Cancel a transaction
         * @param {string} id Transaction ID
         * @param {CancelTransactionForDeveloperRequest} cancelTransactionForDeveloperRequest Cancel transaction for developer request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeveloperTransactionCancel(id: string, cancelTransactionForDeveloperRequest: CancelTransactionForDeveloperRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDeveloperTransactionCancel200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeveloperTransactionCancel(id, cancelTransactionForDeveloperRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a transaction which executes a smart contract. ABI parameters must be passed in the request.
         * @summary Create a contract execution transaction
         * @param {CreateContractExecutionTransactionForDeveloperRequest} createContractExecutionTransactionForDeveloperRequest Create transaction for developer request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeveloperTransactionContractExecution(createContractExecutionTransactionForDeveloperRequest: CreateContractExecutionTransactionForDeveloperRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDeveloperTransactionContractExecution200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeveloperTransactionContractExecution(createContractExecutionTransactionForDeveloperRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initiates an on-chain digital asset transfer from a specified developer-controlled wallet.
         * @summary Create a transfer transaction
         * @param {CreateTransferTransactionForDeveloperRequest} createTransferTransactionForDeveloperRequest Create transaction for developer request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeveloperTransactionTransfer(createTransferTransactionForDeveloperRequest: CreateTransferTransactionForDeveloperRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDeveloperTransactionTransfer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeveloperTransactionTransfer(createTransferTransactionForDeveloperRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Estimates gas fees that will be incurred for a contract execution transaction, given its ABI parameters and blockchain.
         * @summary Estimate fee for a contract execution transaction
         * @param {EstimateContractExecutionTransactionFeeRequest} estimateContractExecutionTransactionFeeRequest Estimate transaction fee request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransactionEstimateFee(estimateContractExecutionTransactionFeeRequest: EstimateContractExecutionTransactionFeeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTransferEstimateFee200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransactionEstimateFee(estimateContractExecutionTransactionFeeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Estimates gas fees that will be incurred for a transfer transaction; given its amount, blockchain, and token.
         * @summary Estimate fee for a transfer transaction
         * @param {EstimateTransferTransactionFeeRequest} estimateTransferTransactionFeeRequest Estimate transaction fee request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransferEstimateFee(estimateTransferTransactionFeeRequest: EstimateTransferTransactionFeeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTransferEstimateFee200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransferEstimateFee(estimateTransferTransactionFeeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates a challenge for accelerating a specified on-chain digital asset transfer from a user-controlled wallet. Additional gas fees may be incurred.
         * @summary Create a Challenge to accelerate a transaction
         * @param {string} id Transaction ID
         * @param {string} xUserToken User token
         * @param {AccelerateTransactionForEndUserRequest} accelerateTransactionForEndUserRequest Accelerate transaction for end user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserTransactionAccelerateChallenge(id: string, xUserToken: string, accelerateTransactionForEndUserRequest: AccelerateTransactionForEndUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserTransactionAccelerateChallenge200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserTransactionAccelerateChallenge(id, xUserToken, accelerateTransactionForEndUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates a challenge for cancelling a specified on-chain digital asset transfer from a user-controlled wallet. Gas fees may still be incurred.
         * @summary Create a challenge to cancel a transaction
         * @param {string} id Transaction ID
         * @param {string} xUserToken User token
         * @param {CancelTransactionForEndUserRequest} cancelTransactionForEndUserRequest Cancel transaction for end user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserTransactionCancelChallenge(id: string, xUserToken: string, cancelTransactionForEndUserRequest: CancelTransactionForEndUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserTransactionCancelChallenge200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserTransactionCancelChallenge(id, xUserToken, cancelTransactionForEndUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates a challenge for creating a transaction which executes a smart contract. ABI parameters must be passed in the request.
         * @summary Create a challenge for contract execution
         * @param {string} xUserToken User token
         * @param {ContractExecutionTxnPinCodeRequest} contractExecutionTxnPinCodeRequest Create transaction for end user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserTransactionContractExecutionChallenge(xUserToken: string, contractExecutionTxnPinCodeRequest: ContractExecutionTxnPinCodeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserTransactionContractExecutionChallenge200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserTransactionContractExecutionChallenge(xUserToken, contractExecutionTxnPinCodeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates a challenge for initiating an on-chain digital asset transfer from a specified user-controlled wallet
         * @summary Create a challenge for a transfer
         * @param {string} xUserToken User token
         * @param {CreateTransferTransactionForEndUserRequest} createTransferTransactionForEndUserRequest Create transaction for end user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserTransactionTransferChallenge(xUserToken: string, createTransferTransactionForEndUserRequest: CreateTransferTransactionForEndUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserTransactionTransferChallenge200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserTransactionTransferChallenge(xUserToken, createTransferTransactionForEndUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Confirms that a specified address is valid for a given token on a certain blockchain.
         * @summary Validate an address
         * @param {ValidateAddressRequest} validateAddressRequest Validate address request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createValidateAddress(validateAddressRequest: ValidateAddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateValidateAddress200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createValidateAddress(validateAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves info for a single transaction using it\'s unique identifier.
         * @summary Get a transaction
         * @param {string} id Transaction id
         * @param {string} [xUserToken] User token
         * @param {GetTransactionTxTypeEnum} [txType] TxType filters on the TxType of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransaction(id: string, xUserToken?: string, txType?: GetTransactionTxTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransaction200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransaction(id, xUserToken, txType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all transactions. Includes details such as status, source/destination, and transaction hash.
         * @summary List transactions
         * @param {string} [xUserToken] User token
         * @param {ListTransactionsBlockchainEnum} [blockchain] Blockchain filters on the blockchain of the transaction
         * @param {ListTransactionsCustodyTypeEnum} [custodyType] CustodyType filters on the CustodyType of the transaction
         * @param {string} [destinationAddress] DestinationAddress filters on the DestinationAddress of the transaction
         * @param {boolean} [includeAll] 
         * @param {ListTransactionsOperationEnum} [operation] Operation filters on the Operation of the transaction
         * @param {ListTransactionsStateEnum} [state] State filters on the state of the transaction
         * @param {string} [txHash] TxHash filters on the TxHash of the transaction
         * @param {ListTransactionsTxTypeEnum} [txType] TxType filters on the TxType of the transaction
         * @param {string} [walletIds] WalletIDs filters on the wallet ids of the transaction
         * @param {string} [from] From is the start time of the query, inclusive
         * @param {string} [to] To is the end time of the query, inclusive, default to current time
         * @param {string} [pageBefore] PageBefore is used to return items before the given item exclusively. SHOULD NOT be used in conjunction with pageAfter
         * @param {string} [pageAfter] PageAfter is used to return items after the given item exclusively. SHOULD NOT be used in conjunction with pageBefore
         * @param {number} [pageSize] PageSize is the number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactions(xUserToken?: string, blockchain?: ListTransactionsBlockchainEnum, custodyType?: ListTransactionsCustodyTypeEnum, destinationAddress?: string, includeAll?: boolean, operation?: ListTransactionsOperationEnum, state?: ListTransactionsStateEnum, txHash?: string, txType?: ListTransactionsTxTypeEnum, walletIds?: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTransactions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactions(xUserToken, blockchain, custodyType, destinationAddress, includeAll, operation, state, txHash, txType, walletIds, from, to, pageBefore, pageAfter, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * Accelerates a specified on-chain digital asset transfer from a developer-controlled wallet. Additional gas fees may be incurred.
         * @summary Accelerate a transaction
         * @param {string} id Transaction ID
         * @param {AccelerateTransactionForDeveloperRequest} accelerateTransactionForDeveloperRequest Accelerate transaction for developer request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeveloperTransactionAccelerate(id: string, accelerateTransactionForDeveloperRequest: AccelerateTransactionForDeveloperRequest, options?: any): AxiosPromise<CreateDeveloperTransactionAccelerate200Response> {
            return localVarFp.createDeveloperTransactionAccelerate(id, accelerateTransactionForDeveloperRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels a specified on-chain digital asset transfer from a developer-controlled wallet. Gas fees may still be incurred.
         * @summary Cancel a transaction
         * @param {string} id Transaction ID
         * @param {CancelTransactionForDeveloperRequest} cancelTransactionForDeveloperRequest Cancel transaction for developer request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeveloperTransactionCancel(id: string, cancelTransactionForDeveloperRequest: CancelTransactionForDeveloperRequest, options?: any): AxiosPromise<CreateDeveloperTransactionCancel200Response> {
            return localVarFp.createDeveloperTransactionCancel(id, cancelTransactionForDeveloperRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a transaction which executes a smart contract. ABI parameters must be passed in the request.
         * @summary Create a contract execution transaction
         * @param {CreateContractExecutionTransactionForDeveloperRequest} createContractExecutionTransactionForDeveloperRequest Create transaction for developer request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeveloperTransactionContractExecution(createContractExecutionTransactionForDeveloperRequest: CreateContractExecutionTransactionForDeveloperRequest, options?: any): AxiosPromise<CreateDeveloperTransactionContractExecution200Response> {
            return localVarFp.createDeveloperTransactionContractExecution(createContractExecutionTransactionForDeveloperRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates an on-chain digital asset transfer from a specified developer-controlled wallet.
         * @summary Create a transfer transaction
         * @param {CreateTransferTransactionForDeveloperRequest} createTransferTransactionForDeveloperRequest Create transaction for developer request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeveloperTransactionTransfer(createTransferTransactionForDeveloperRequest: CreateTransferTransactionForDeveloperRequest, options?: any): AxiosPromise<CreateDeveloperTransactionTransfer200Response> {
            return localVarFp.createDeveloperTransactionTransfer(createTransferTransactionForDeveloperRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Estimates gas fees that will be incurred for a contract execution transaction, given its ABI parameters and blockchain.
         * @summary Estimate fee for a contract execution transaction
         * @param {EstimateContractExecutionTransactionFeeRequest} estimateContractExecutionTransactionFeeRequest Estimate transaction fee request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionEstimateFee(estimateContractExecutionTransactionFeeRequest: EstimateContractExecutionTransactionFeeRequest, options?: any): AxiosPromise<CreateTransferEstimateFee200Response> {
            return localVarFp.createTransactionEstimateFee(estimateContractExecutionTransactionFeeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Estimates gas fees that will be incurred for a transfer transaction; given its amount, blockchain, and token.
         * @summary Estimate fee for a transfer transaction
         * @param {EstimateTransferTransactionFeeRequest} estimateTransferTransactionFeeRequest Estimate transaction fee request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransferEstimateFee(estimateTransferTransactionFeeRequest: EstimateTransferTransactionFeeRequest, options?: any): AxiosPromise<CreateTransferEstimateFee200Response> {
            return localVarFp.createTransferEstimateFee(estimateTransferTransactionFeeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a challenge for accelerating a specified on-chain digital asset transfer from a user-controlled wallet. Additional gas fees may be incurred.
         * @summary Create a Challenge to accelerate a transaction
         * @param {string} id Transaction ID
         * @param {string} xUserToken User token
         * @param {AccelerateTransactionForEndUserRequest} accelerateTransactionForEndUserRequest Accelerate transaction for end user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserTransactionAccelerateChallenge(id: string, xUserToken: string, accelerateTransactionForEndUserRequest: AccelerateTransactionForEndUserRequest, options?: any): AxiosPromise<CreateUserTransactionAccelerateChallenge200Response> {
            return localVarFp.createUserTransactionAccelerateChallenge(id, xUserToken, accelerateTransactionForEndUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a challenge for cancelling a specified on-chain digital asset transfer from a user-controlled wallet. Gas fees may still be incurred.
         * @summary Create a challenge to cancel a transaction
         * @param {string} id Transaction ID
         * @param {string} xUserToken User token
         * @param {CancelTransactionForEndUserRequest} cancelTransactionForEndUserRequest Cancel transaction for end user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserTransactionCancelChallenge(id: string, xUserToken: string, cancelTransactionForEndUserRequest: CancelTransactionForEndUserRequest, options?: any): AxiosPromise<CreateUserTransactionCancelChallenge200Response> {
            return localVarFp.createUserTransactionCancelChallenge(id, xUserToken, cancelTransactionForEndUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a challenge for creating a transaction which executes a smart contract. ABI parameters must be passed in the request.
         * @summary Create a challenge for contract execution
         * @param {string} xUserToken User token
         * @param {ContractExecutionTxnPinCodeRequest} contractExecutionTxnPinCodeRequest Create transaction for end user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserTransactionContractExecutionChallenge(xUserToken: string, contractExecutionTxnPinCodeRequest: ContractExecutionTxnPinCodeRequest, options?: any): AxiosPromise<CreateUserTransactionContractExecutionChallenge200Response> {
            return localVarFp.createUserTransactionContractExecutionChallenge(xUserToken, contractExecutionTxnPinCodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a challenge for initiating an on-chain digital asset transfer from a specified user-controlled wallet
         * @summary Create a challenge for a transfer
         * @param {string} xUserToken User token
         * @param {CreateTransferTransactionForEndUserRequest} createTransferTransactionForEndUserRequest Create transaction for end user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserTransactionTransferChallenge(xUserToken: string, createTransferTransactionForEndUserRequest: CreateTransferTransactionForEndUserRequest, options?: any): AxiosPromise<CreateUserTransactionTransferChallenge200Response> {
            return localVarFp.createUserTransactionTransferChallenge(xUserToken, createTransferTransactionForEndUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Confirms that a specified address is valid for a given token on a certain blockchain.
         * @summary Validate an address
         * @param {ValidateAddressRequest} validateAddressRequest Validate address request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createValidateAddress(validateAddressRequest: ValidateAddressRequest, options?: any): AxiosPromise<CreateValidateAddress200Response> {
            return localVarFp.createValidateAddress(validateAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves info for a single transaction using it\'s unique identifier.
         * @summary Get a transaction
         * @param {string} id Transaction id
         * @param {string} [xUserToken] User token
         * @param {GetTransactionTxTypeEnum} [txType] TxType filters on the TxType of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction(id: string, xUserToken?: string, txType?: GetTransactionTxTypeEnum, options?: any): AxiosPromise<GetTransaction200Response> {
            return localVarFp.getTransaction(id, xUserToken, txType, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all transactions. Includes details such as status, source/destination, and transaction hash.
         * @summary List transactions
         * @param {string} [xUserToken] User token
         * @param {ListTransactionsBlockchainEnum} [blockchain] Blockchain filters on the blockchain of the transaction
         * @param {ListTransactionsCustodyTypeEnum} [custodyType] CustodyType filters on the CustodyType of the transaction
         * @param {string} [destinationAddress] DestinationAddress filters on the DestinationAddress of the transaction
         * @param {boolean} [includeAll] 
         * @param {ListTransactionsOperationEnum} [operation] Operation filters on the Operation of the transaction
         * @param {ListTransactionsStateEnum} [state] State filters on the state of the transaction
         * @param {string} [txHash] TxHash filters on the TxHash of the transaction
         * @param {ListTransactionsTxTypeEnum} [txType] TxType filters on the TxType of the transaction
         * @param {string} [walletIds] WalletIDs filters on the wallet ids of the transaction
         * @param {string} [from] From is the start time of the query, inclusive
         * @param {string} [to] To is the end time of the query, inclusive, default to current time
         * @param {string} [pageBefore] PageBefore is used to return items before the given item exclusively. SHOULD NOT be used in conjunction with pageAfter
         * @param {string} [pageAfter] PageAfter is used to return items after the given item exclusively. SHOULD NOT be used in conjunction with pageBefore
         * @param {number} [pageSize] PageSize is the number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions(xUserToken?: string, blockchain?: ListTransactionsBlockchainEnum, custodyType?: ListTransactionsCustodyTypeEnum, destinationAddress?: string, includeAll?: boolean, operation?: ListTransactionsOperationEnum, state?: ListTransactionsStateEnum, txHash?: string, txType?: ListTransactionsTxTypeEnum, walletIds?: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: any): AxiosPromise<ListTransactions200Response> {
            return localVarFp.listTransactions(xUserToken, blockchain, custodyType, destinationAddress, includeAll, operation, state, txHash, txType, walletIds, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Accelerates a specified on-chain digital asset transfer from a developer-controlled wallet. Additional gas fees may be incurred.
     * @summary Accelerate a transaction
     * @param {string} id Transaction ID
     * @param {AccelerateTransactionForDeveloperRequest} accelerateTransactionForDeveloperRequest Accelerate transaction for developer request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createDeveloperTransactionAccelerate(id: string, accelerateTransactionForDeveloperRequest: AccelerateTransactionForDeveloperRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createDeveloperTransactionAccelerate(id, accelerateTransactionForDeveloperRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels a specified on-chain digital asset transfer from a developer-controlled wallet. Gas fees may still be incurred.
     * @summary Cancel a transaction
     * @param {string} id Transaction ID
     * @param {CancelTransactionForDeveloperRequest} cancelTransactionForDeveloperRequest Cancel transaction for developer request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createDeveloperTransactionCancel(id: string, cancelTransactionForDeveloperRequest: CancelTransactionForDeveloperRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createDeveloperTransactionCancel(id, cancelTransactionForDeveloperRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a transaction which executes a smart contract. ABI parameters must be passed in the request.
     * @summary Create a contract execution transaction
     * @param {CreateContractExecutionTransactionForDeveloperRequest} createContractExecutionTransactionForDeveloperRequest Create transaction for developer request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createDeveloperTransactionContractExecution(createContractExecutionTransactionForDeveloperRequest: CreateContractExecutionTransactionForDeveloperRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createDeveloperTransactionContractExecution(createContractExecutionTransactionForDeveloperRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiates an on-chain digital asset transfer from a specified developer-controlled wallet.
     * @summary Create a transfer transaction
     * @param {CreateTransferTransactionForDeveloperRequest} createTransferTransactionForDeveloperRequest Create transaction for developer request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createDeveloperTransactionTransfer(createTransferTransactionForDeveloperRequest: CreateTransferTransactionForDeveloperRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createDeveloperTransactionTransfer(createTransferTransactionForDeveloperRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Estimates gas fees that will be incurred for a contract execution transaction, given its ABI parameters and blockchain.
     * @summary Estimate fee for a contract execution transaction
     * @param {EstimateContractExecutionTransactionFeeRequest} estimateContractExecutionTransactionFeeRequest Estimate transaction fee request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createTransactionEstimateFee(estimateContractExecutionTransactionFeeRequest: EstimateContractExecutionTransactionFeeRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createTransactionEstimateFee(estimateContractExecutionTransactionFeeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Estimates gas fees that will be incurred for a transfer transaction; given its amount, blockchain, and token.
     * @summary Estimate fee for a transfer transaction
     * @param {EstimateTransferTransactionFeeRequest} estimateTransferTransactionFeeRequest Estimate transaction fee request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createTransferEstimateFee(estimateTransferTransactionFeeRequest: EstimateTransferTransactionFeeRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createTransferEstimateFee(estimateTransferTransactionFeeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a challenge for accelerating a specified on-chain digital asset transfer from a user-controlled wallet. Additional gas fees may be incurred.
     * @summary Create a Challenge to accelerate a transaction
     * @param {string} id Transaction ID
     * @param {string} xUserToken User token
     * @param {AccelerateTransactionForEndUserRequest} accelerateTransactionForEndUserRequest Accelerate transaction for end user request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createUserTransactionAccelerateChallenge(id: string, xUserToken: string, accelerateTransactionForEndUserRequest: AccelerateTransactionForEndUserRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createUserTransactionAccelerateChallenge(id, xUserToken, accelerateTransactionForEndUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a challenge for cancelling a specified on-chain digital asset transfer from a user-controlled wallet. Gas fees may still be incurred.
     * @summary Create a challenge to cancel a transaction
     * @param {string} id Transaction ID
     * @param {string} xUserToken User token
     * @param {CancelTransactionForEndUserRequest} cancelTransactionForEndUserRequest Cancel transaction for end user request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createUserTransactionCancelChallenge(id: string, xUserToken: string, cancelTransactionForEndUserRequest: CancelTransactionForEndUserRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createUserTransactionCancelChallenge(id, xUserToken, cancelTransactionForEndUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a challenge for creating a transaction which executes a smart contract. ABI parameters must be passed in the request.
     * @summary Create a challenge for contract execution
     * @param {string} xUserToken User token
     * @param {ContractExecutionTxnPinCodeRequest} contractExecutionTxnPinCodeRequest Create transaction for end user request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createUserTransactionContractExecutionChallenge(xUserToken: string, contractExecutionTxnPinCodeRequest: ContractExecutionTxnPinCodeRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createUserTransactionContractExecutionChallenge(xUserToken, contractExecutionTxnPinCodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a challenge for initiating an on-chain digital asset transfer from a specified user-controlled wallet
     * @summary Create a challenge for a transfer
     * @param {string} xUserToken User token
     * @param {CreateTransferTransactionForEndUserRequest} createTransferTransactionForEndUserRequest Create transaction for end user request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createUserTransactionTransferChallenge(xUserToken: string, createTransferTransactionForEndUserRequest: CreateTransferTransactionForEndUserRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createUserTransactionTransferChallenge(xUserToken, createTransferTransactionForEndUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Confirms that a specified address is valid for a given token on a certain blockchain.
     * @summary Validate an address
     * @param {ValidateAddressRequest} validateAddressRequest Validate address request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createValidateAddress(validateAddressRequest: ValidateAddressRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createValidateAddress(validateAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves info for a single transaction using it\'s unique identifier.
     * @summary Get a transaction
     * @param {string} id Transaction id
     * @param {string} [xUserToken] User token
     * @param {GetTransactionTxTypeEnum} [txType] TxType filters on the TxType of the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransaction(id: string, xUserToken?: string, txType?: GetTransactionTxTypeEnum, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransaction(id, xUserToken, txType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all transactions. Includes details such as status, source/destination, and transaction hash.
     * @summary List transactions
     * @param {string} [xUserToken] User token
     * @param {ListTransactionsBlockchainEnum} [blockchain] Blockchain filters on the blockchain of the transaction
     * @param {ListTransactionsCustodyTypeEnum} [custodyType] CustodyType filters on the CustodyType of the transaction
     * @param {string} [destinationAddress] DestinationAddress filters on the DestinationAddress of the transaction
     * @param {boolean} [includeAll] 
     * @param {ListTransactionsOperationEnum} [operation] Operation filters on the Operation of the transaction
     * @param {ListTransactionsStateEnum} [state] State filters on the state of the transaction
     * @param {string} [txHash] TxHash filters on the TxHash of the transaction
     * @param {ListTransactionsTxTypeEnum} [txType] TxType filters on the TxType of the transaction
     * @param {string} [walletIds] WalletIDs filters on the wallet ids of the transaction
     * @param {string} [from] From is the start time of the query, inclusive
     * @param {string} [to] To is the end time of the query, inclusive, default to current time
     * @param {string} [pageBefore] PageBefore is used to return items before the given item exclusively. SHOULD NOT be used in conjunction with pageAfter
     * @param {string} [pageAfter] PageAfter is used to return items after the given item exclusively. SHOULD NOT be used in conjunction with pageBefore
     * @param {number} [pageSize] PageSize is the number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public listTransactions(xUserToken?: string, blockchain?: ListTransactionsBlockchainEnum, custodyType?: ListTransactionsCustodyTypeEnum, destinationAddress?: string, includeAll?: boolean, operation?: ListTransactionsOperationEnum, state?: ListTransactionsStateEnum, txHash?: string, txType?: ListTransactionsTxTypeEnum, walletIds?: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).listTransactions(xUserToken, blockchain, custodyType, destinationAddress, includeAll, operation, state, txHash, txType, walletIds, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetTransactionTxTypeEnum = {
    Inbound: 'INBOUND',
    Outbound: 'OUTBOUND'
} as const;
export type GetTransactionTxTypeEnum = typeof GetTransactionTxTypeEnum[keyof typeof GetTransactionTxTypeEnum];
/**
 * @export
 */
export const ListTransactionsBlockchainEnum = {
    Eth: 'ETH',
    EthGoerli: 'ETH-GOERLI',
    Avax: 'AVAX',
    AvaxFuji: 'AVAX-FUJI',
    Matic: 'MATIC',
    MaticMumbai: 'MATIC-MUMBAI'
} as const;
export type ListTransactionsBlockchainEnum = typeof ListTransactionsBlockchainEnum[keyof typeof ListTransactionsBlockchainEnum];
/**
 * @export
 */
export const ListTransactionsCustodyTypeEnum = {
    Developer: 'DEVELOPER',
    Enduser: 'ENDUSER'
} as const;
export type ListTransactionsCustodyTypeEnum = typeof ListTransactionsCustodyTypeEnum[keyof typeof ListTransactionsCustodyTypeEnum];
/**
 * @export
 */
export const ListTransactionsOperationEnum = {
    Transfer: 'TRANSFER',
    ContractExecution: 'CONTRACT_EXECUTION',
    ContractDeployment: 'CONTRACT_DEPLOYMENT'
} as const;
export type ListTransactionsOperationEnum = typeof ListTransactionsOperationEnum[keyof typeof ListTransactionsOperationEnum];
/**
 * @export
 */
export const ListTransactionsStateEnum = {
    Initiated: 'INITIATED',
    PendingRiskScreening: 'PENDING_RISK_SCREENING',
    Denied: 'DENIED',
    Queued: 'QUEUED',
    Sent: 'SENT',
    Confirmed: 'CONFIRMED',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED'
} as const;
export type ListTransactionsStateEnum = typeof ListTransactionsStateEnum[keyof typeof ListTransactionsStateEnum];
/**
 * @export
 */
export const ListTransactionsTxTypeEnum = {
    Inbound: 'INBOUND',
    Outbound: 'OUTBOUND'
} as const;
export type ListTransactionsTxTypeEnum = typeof ListTransactionsTxTypeEnum[keyof typeof ListTransactionsTxTypeEnum];
