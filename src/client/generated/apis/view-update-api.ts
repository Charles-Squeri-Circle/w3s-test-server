/* tslint:disable */
/* eslint-disable */
/**
 * W3S
 * All W3S APIs
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ImportContract200Response } from '../models';
// @ts-ignore
import { ListContracts200Response } from '../models';
// @ts-ignore
import { ScpSchemasPatchContractRequest } from '../models';
/**
 * ViewUpdateApi - axios parameter creator
 * @export
 */
export const ViewUpdateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a single contract that you\'ve imported or deployed. Retrieved using the contracts ID as opposed to the on-chain address.
         * @summary Get a contract
         * @param {string} id Contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContract: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getContract', 'id', id)
            const localVarPath = `/contracts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of contracts that you\'ve imported and/or deployed.
         * @summary List contracts
         * @param {ListContractsBlockchainEnum} [blockchain] Filter by blockchain.
         * @param {ListContractsContractInputTypeEnum} [contractInputType] Filter contracts by input type.
         * @param {string} [deployerAddress] Filter contracts by deployer address.
         * @param {string} [name] Filter contracts by name.
         * @param {ListContractsStatusEnum} [status] Filter contracts by status.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next n items before the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.   SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next n items after the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.   Some collections have a strict upper bound that will disregard this value. In case the specified value is higher  than the allowed limit, the collection limit will be used.   If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContracts: async (blockchain?: ListContractsBlockchainEnum, contractInputType?: ListContractsContractInputTypeEnum, deployerAddress?: string, name?: string, status?: ListContractsStatusEnum, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (blockchain !== undefined) {
                localVarQueryParameter['blockchain'] = blockchain;
            }

            if (contractInputType !== undefined) {
                localVarQueryParameter['contractInputType'] = contractInputType;
            }

            if (deployerAddress !== undefined) {
                localVarQueryParameter['deployerAddress'] = deployerAddress;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (pageBefore !== undefined) {
                localVarQueryParameter['pageBefore'] = pageBefore;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['pageAfter'] = pageAfter;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the off-chain properties, such as description, of a contract that you\'ve imported or deployed. Updated using the contracts ID as opposed to the on-chain address.
         * @summary Update a contract
         * @param {string} id Contract id
         * @param {ScpSchemasPatchContractRequest} scpSchemasPatchContractRequest Update contract properties request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContract: async (id: string, scpSchemasPatchContractRequest: ScpSchemasPatchContractRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateContract', 'id', id)
            // verify required parameter 'scpSchemasPatchContractRequest' is not null or undefined
            assertParamExists('updateContract', 'scpSchemasPatchContractRequest', scpSchemasPatchContractRequest)
            const localVarPath = `/contracts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scpSchemasPatchContractRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewUpdateApi - functional programming interface
 * @export
 */
export const ViewUpdateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ViewUpdateApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a single contract that you\'ve imported or deployed. Retrieved using the contracts ID as opposed to the on-chain address.
         * @summary Get a contract
         * @param {string} id Contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContract(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportContract200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContract(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a list of contracts that you\'ve imported and/or deployed.
         * @summary List contracts
         * @param {ListContractsBlockchainEnum} [blockchain] Filter by blockchain.
         * @param {ListContractsContractInputTypeEnum} [contractInputType] Filter contracts by input type.
         * @param {string} [deployerAddress] Filter contracts by deployer address.
         * @param {string} [name] Filter contracts by name.
         * @param {ListContractsStatusEnum} [status] Filter contracts by status.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next n items before the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.   SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next n items after the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.   Some collections have a strict upper bound that will disregard this value. In case the specified value is higher  than the allowed limit, the collection limit will be used.   If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContracts(blockchain?: ListContractsBlockchainEnum, contractInputType?: ListContractsContractInputTypeEnum, deployerAddress?: string, name?: string, status?: ListContractsStatusEnum, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListContracts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContracts(blockchain, contractInputType, deployerAddress, name, status, from, to, pageBefore, pageAfter, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the off-chain properties, such as description, of a contract that you\'ve imported or deployed. Updated using the contracts ID as opposed to the on-chain address.
         * @summary Update a contract
         * @param {string} id Contract id
         * @param {ScpSchemasPatchContractRequest} scpSchemasPatchContractRequest Update contract properties request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContract(id: string, scpSchemasPatchContractRequest: ScpSchemasPatchContractRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportContract200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContract(id, scpSchemasPatchContractRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ViewUpdateApi - factory interface
 * @export
 */
export const ViewUpdateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ViewUpdateApiFp(configuration)
    return {
        /**
         * Get a single contract that you\'ve imported or deployed. Retrieved using the contracts ID as opposed to the on-chain address.
         * @summary Get a contract
         * @param {string} id Contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContract(id: string, options?: any): AxiosPromise<ImportContract200Response> {
            return localVarFp.getContract(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of contracts that you\'ve imported and/or deployed.
         * @summary List contracts
         * @param {ListContractsBlockchainEnum} [blockchain] Filter by blockchain.
         * @param {ListContractsContractInputTypeEnum} [contractInputType] Filter contracts by input type.
         * @param {string} [deployerAddress] Filter contracts by deployer address.
         * @param {string} [name] Filter contracts by name.
         * @param {ListContractsStatusEnum} [status] Filter contracts by status.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next n items before the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.   SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next n items after the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.   Some collections have a strict upper bound that will disregard this value. In case the specified value is higher  than the allowed limit, the collection limit will be used.   If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContracts(blockchain?: ListContractsBlockchainEnum, contractInputType?: ListContractsContractInputTypeEnum, deployerAddress?: string, name?: string, status?: ListContractsStatusEnum, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: any): AxiosPromise<ListContracts200Response> {
            return localVarFp.listContracts(blockchain, contractInputType, deployerAddress, name, status, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the off-chain properties, such as description, of a contract that you\'ve imported or deployed. Updated using the contracts ID as opposed to the on-chain address.
         * @summary Update a contract
         * @param {string} id Contract id
         * @param {ScpSchemasPatchContractRequest} scpSchemasPatchContractRequest Update contract properties request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContract(id: string, scpSchemasPatchContractRequest: ScpSchemasPatchContractRequest, options?: any): AxiosPromise<ImportContract200Response> {
            return localVarFp.updateContract(id, scpSchemasPatchContractRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ViewUpdateApi - object-oriented interface
 * @export
 * @class ViewUpdateApi
 * @extends {BaseAPI}
 */
export class ViewUpdateApi extends BaseAPI {
    /**
     * Get a single contract that you\'ve imported or deployed. Retrieved using the contracts ID as opposed to the on-chain address.
     * @summary Get a contract
     * @param {string} id Contract id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewUpdateApi
     */
    public getContract(id: string, options?: AxiosRequestConfig) {
        return ViewUpdateApiFp(this.configuration).getContract(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a list of contracts that you\'ve imported and/or deployed.
     * @summary List contracts
     * @param {ListContractsBlockchainEnum} [blockchain] Filter by blockchain.
     * @param {ListContractsContractInputTypeEnum} [contractInputType] Filter contracts by input type.
     * @param {string} [deployerAddress] Filter contracts by deployer address.
     * @param {string} [name] Filter contracts by name.
     * @param {ListContractsStatusEnum} [status] Filter contracts by status.
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next n items before the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.   SHOULD NOT be used in conjuction with pageAfter. 
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next n items after the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.  SHOULD NOT be used in conjuction with pageBefore. 
     * @param {number} [pageSize] Limits the number of items to be returned.   Some collections have a strict upper bound that will disregard this value. In case the specified value is higher  than the allowed limit, the collection limit will be used.   If avoided, the collection will determine the page size itself. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewUpdateApi
     */
    public listContracts(blockchain?: ListContractsBlockchainEnum, contractInputType?: ListContractsContractInputTypeEnum, deployerAddress?: string, name?: string, status?: ListContractsStatusEnum, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return ViewUpdateApiFp(this.configuration).listContracts(blockchain, contractInputType, deployerAddress, name, status, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the off-chain properties, such as description, of a contract that you\'ve imported or deployed. Updated using the contracts ID as opposed to the on-chain address.
     * @summary Update a contract
     * @param {string} id Contract id
     * @param {ScpSchemasPatchContractRequest} scpSchemasPatchContractRequest Update contract properties request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewUpdateApi
     */
    public updateContract(id: string, scpSchemasPatchContractRequest: ScpSchemasPatchContractRequest, options?: AxiosRequestConfig) {
        return ViewUpdateApiFp(this.configuration).updateContract(id, scpSchemasPatchContractRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListContractsBlockchainEnum = {
    Eth: 'ETH',
    EthGoerli: 'ETH-GOERLI',
    Matic: 'MATIC',
    MaticMumbai: 'MATIC-MUMBAI'
} as const;
export type ListContractsBlockchainEnum = typeof ListContractsBlockchainEnum[keyof typeof ListContractsBlockchainEnum];
/**
 * @export
 */
export const ListContractsContractInputTypeEnum = {
    Import: 'IMPORT',
    Bytecode: 'BYTECODE'
} as const;
export type ListContractsContractInputTypeEnum = typeof ListContractsContractInputTypeEnum[keyof typeof ListContractsContractInputTypeEnum];
/**
 * @export
 */
export const ListContractsStatusEnum = {
    Pending: 'PENDING',
    Failed: 'FAILED',
    Complete: 'COMPLETE'
} as const;
export type ListContractsStatusEnum = typeof ListContractsStatusEnum[keyof typeof ListContractsStatusEnum];
